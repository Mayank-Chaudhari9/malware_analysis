#include "opcodeFile.h"
#include "trie.h"
#include <assert.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#define MEAN 0
#define VAR 1
#define FREQUENCY 1
// TODO update all enums with
// http://stackoverflow.com/questions/1102542/how-to-define-an-enumerated-type-enum-in-c
// TODO Garbage Collection
enum classId{ BENIGN=0, MALWARE=1, UNKNOWN };
int getClassId(
        char * cls
        )
{
    if ( strcmp( cls, "MALWARE") == 0 ) return MALWARE;
    if ( strcmp( cls, "BENIGN") == 0 ) return BENIGN;
    return -1;
}

void initFiles(
        s_files ** p_files
        )
{
    *p_files = (s_files*) malloc ( sizeof(s_files) );
    (*p_files)->list = NULL;
    (*p_files)->garb = NULL;
}

void initFileList(
        s_filelist ** p_list
        )
{
    (*p_list) = (s_filelist*) malloc ( sizeof( s_filelist) ) ;
    (*p_list)->count = 0;
    (*p_list)->list = NULL;
}

void initGroups(
        s_group ** out_groups,
        int in_count
        )
{
    (*out_groups) = (s_group*) calloc(sizeof(s_group), in_count);
    int i;
    for ( i=0; i<in_count; i++)
    {
        (*out_groups)[i].list[0].list = NULL;
        (*out_groups)[i].list[0].count = 0;
        (*out_groups)[i].list[1].list = NULL;
        (*out_groups)[i].list[1].count = 0;
        (*out_groups)[i].trainlist.list = NULL;
        (*out_groups)[i].trainlist.count = 0;
        (*out_groups)[i].testlist.list = NULL;
        (*out_groups)[i].testlist.count = 0;
        (*out_groups)[i].features = NULL;
    }
}

s_fileProp* createFileNode(
        char *filename,
        int filesize,
        char *data_type,
        char *cls,
        int numopcode,
        int totalopcodes
        )
{
    int err =0;
    s_fileProp* temp = (s_fileProp*) malloc( sizeof(s_fileProp) );
    err = errno;
    if( temp == NULL || errno )
    {
        printf(" Malloc Failed %s\n", strerror(err));
        exit(1);
        return NULL;
    }
    temp->name = (char*) malloc( sizeof(char) * (strlen(filename)+1) );
    strcpy( temp->name ,filename);
    temp->numopcode = numopcode;
    temp->size = filesize;
    temp->classId   = getClassId(cls);
    temp->opcodes = (s_opcodenode*) calloc ( sizeof(s_opcodenode) , numopcode);
    temp->normalized_opcodes = (float*) calloc ( sizeof(float) , numopcode);
    return temp;
}

void createFeatureListForEachGroup(
        int ***out_feature_list,
        int in_num_groups
        )
{
    (*out_feature_list) = (int**) calloc( sizeof(int*), in_num_groups);
}

void addToFiles(
        s_files ** p_files,
        s_fileProp ** p_fileprop
        )
{
    (*p_files)->numFiles ++;
    if( (*p_files)->list== NULL )
    {
        (*p_files)->list = (*p_fileprop);
        return;
    }
    (*p_fileprop)->next = (*p_files)->list;
    (*p_files)->list = (*p_fileprop);
    return;
}

void addToList(
        s_filelist * p_list,
        s_fileProp * p_prop
        )
{
    s_filelistnode *temp = NULL;
    temp = (s_filelistnode*) malloc (sizeof(s_filelistnode) );
    temp->prop = p_prop;
    temp->next = NULL;
    if( (p_list)->list == NULL)
    {
        (p_list)->list =temp;
        (p_list)->count+=1;
        return;
    }
    temp->next = (p_list)->list;
    (p_list)->list = temp;
    (p_list)->count+=1;
}

void addToGroup(
        s_group ** out_groups,
        int in_gropup_index,
        s_fileProp *in_fileprop
        )
{
    //s_filelistnode *new_node;
    s_filelist *temp;
    s_group *currgrp;
    int currClassId = in_fileprop->classId;

    currgrp =&( (*out_groups)[in_gropup_index] );
    currgrp->count += 1;

    temp = &((*out_groups)[in_gropup_index].list[  currClassId ]);

    addToList( temp, in_fileprop);

    currgrp->max = (in_fileprop->numopcode > currgrp->max) ? in_fileprop->numopcode : currgrp->max ;
    currgrp->min = (in_fileprop->numopcode < currgrp->min) ? in_fileprop->numopcode : currgrp->min ;
}

int readOpcodeFile(
        char* fname,
        s_trie** opcodelist
        )
{
    printf(" [ STEP ] Reading opcode list .... \n");
    FILE *fp;
    int err;
    int numopcodes=0;
    err = errno = 0;
    fp = fopen( fname, "r");
    err = errno;
    if( fp == NULL )
    {
        printf("[ Error ] %s.\n", strerror(err));
        return -1;
    }
    char  *buff=NULL;
    //char  *opcode=NULL;
    size_t count=0;
    size_t readlen=0;
    while( !feof( fp ) )
    {
        readlen = getline( &buff, &count, fp);
        if( readlen == (size_t)-1 ) break ;
        //opcode = strtok( buff, "\n" ); // TODO construct a opcode word list
        numopcodes++;
    }
    fclose( fp );
    return numopcodes;
}

s_fileProp * convertLineToFileProp(
        char *buff,
        int *out_groupcount,
        int in_totalnumopcodes,
        int *out_numFiles
        )
{
    char *filename = strtok( buff, "," );
    char *filesize = strtok( NULL, "," );
    char *data_set = strtok( NULL, "," );
    char *cls      = strtok( NULL, "," );
    char *numopc   = strtok( NULL, "," );
    int numopcode  = atoi( numopc );
    int size = atoi( filesize );
    int index = size/5;
    int max = INT_MIN;
    int min = INT_MAX;

    if( numopcode > 10 && size < 500 )
    {
        out_groupcount[ index*2 + getClassId(cls) ] += 1; // TODO replace 2 with NUM_CLASSES
        s_fileProp *tempfile = createFileNode( filename, size, data_set, cls,
                numopcode, in_totalnumopcodes);
        char *freq;
        int opcodes_found=0;
        int id=0;
        while( (freq = strtok(NULL,",\n")) != NULL )
        {
            int currfreq = atoi(freq);
            if( currfreq > 0)
            {
                if (  currfreq> max ) max = currfreq;
                if ( currfreq< min ) min = currfreq;
                tempfile->opcodes[ opcodes_found ].id = id;
                tempfile->opcodes[ opcodes_found++ ].freq = currfreq ;
                assert( atoi(freq) > 0 );
            }
            id++;
        }
        // THIS IS REALLY WEIRED NEED TO DO SOMETHING ABOUT THIS
        if( opcodes_found< numopcode  ) // Just in case the CSV  as an opcode
        {
            tempfile->numopcode = opcodes_found;
        }
        tempfile->min_opcodefreq = min;
        tempfile->max_opcodefreq = max;
        tempfile->next = NULL;
        (*out_numFiles)++;
        return tempfile;
    }
    return NULL;
}
int readCSVFile(
        char* in_filename,
        int in_numopcode,
        s_files ** out_fillist,
        int *out_groupcount
        )
{
    printf(" [ STEP ] Reading %s file for opcode frequencies ... \n",in_filename);
    FILE *fp;
    int err;
    int numfiles=0;
    err = errno = 0;
    fp = fopen( in_filename, "r");
    err = errno;
    if( fp == NULL )
    {
        printf("[ Error ] %s.\n", strerror(err));
        return -1;
    }
    size_t count=0;
    char  *buff=NULL;

    while( getline(&buff, &count, fp) > 0 )
    {
        s_fileProp *tempfile = convertLineToFileProp( buff, out_groupcount, in_numopcode, &numfiles);
        if( tempfile != NULL)
            addToFiles( out_fillist, &tempfile);
    }
    free( buff );
    fclose( fp );
    return numfiles;
}

void cleanUp(
        s_garbage * p_garbage
        )
{
}

void deleteFiles(
        s_files ** p_files
        )
{
    cleanUp( (*p_files)->garb );
    free( *p_files );
    (*p_files) = NULL;
}


void fillTheMatrix(
        s_files ** p_files,
        int * p_mat,
        int * p_cvect,
        int rows,
        int columns
        )
{
    s_fileProp * list = (*p_files)->list;
    int i=0,j=0;
    while( list!= NULL)
    {
        for( j=0; j<list->numopcode; j++)
        {
            p_mat[ (i*columns)+ list->opcodes[j].id ] = list->opcodes[j].freq;
        }
        p_cvect[i] = list->classId;
        list= list->next;
        i++;
    }
}

void fillTheMatrixFromList(
        s_filelist ** p_files,
        int * p_mat,
        int * p_cvect,
        int rows,
        int columns
        )
{
    s_filelistnode * list = (*p_files)->list;
    int i=0,j=0;
    while( list!= NULL && i<rows)
    {
        for( j=0; j<list->prop->numopcode; j++)
        {
            p_mat[ (i*columns)+ list->prop->opcodes[j].id ] = list->prop->opcodes[j].freq;
        }
        p_cvect[i] = list->prop->classId;
        list= list->next;
        i++;
    }
}


int adjustCountInEachGroup(
        int* out_groupcount,
        int num_groups
        )
{
    int i;
    int count=0;
    for(  i=0; i<num_groups*2; i+=2)
    {
        if( out_groupcount[ i+0 ] > out_groupcount[ i+1 ])
        {
            out_groupcount[ i+0 ] = out_groupcount[ i+1 ];
            count += out_groupcount[i+0];
        }
        else
        {
            out_groupcount[ i+1 ] = out_groupcount[ i+0 ];
            count += out_groupcount[i+1];
        }
    }
    return count*2;
}

/*
 *	@DESC   : Does grouping for only 2 classes
 *          : TODO make it genric for n classes
 *	@PRAM   : What are the parameters?
 *	@RETURN : What does it return?
 *
 */
void doGrouping(
        s_files* in_files,
        int* in_groupcount,
        s_group ** out_groups
        )
{
    printf(" [ STEP ] Grouping files by file size,into buckets of 5kb size ...\n");
    s_fileProp *temp = in_files->list;
    int groupIndex=0;
    int classId=-1;
    int index=0;
    while( temp != NULL )
    {
        groupIndex = temp->size/5;
        classId = temp->classId;
        index = groupIndex*2+ classId;
        if( in_groupcount[ index ] > 0 )
        {

            addToGroup( out_groups, groupIndex, temp );
            in_groupcount[ index ]--;
        }
        temp = temp->next;
    }
}



void normalizeOpcodeFrequency(
        s_files ** out_filelist
        )
{
    printf(" [ STEP ] Normalizing opcode frequencies of each file ... \n");
    s_fileProp * temp;
    temp = (*out_filelist)->list;
    int numfiles = (*out_filelist)->numFiles;
    int i=0, j=0;
    int min=0, max=0;
    for ( i=0; i<numfiles; i++)
    {
        min = temp->min_opcodefreq;
        max = temp->max_opcodefreq;
        s_opcodenode *opc = temp->opcodes;
        float *nopc = temp->normalized_opcodes;
        for ( j=0; j<temp->numopcode; j++)
        {
            nopc[j] = (float)(opc[j].freq - min)/(float)(max - min);
            assert( nopc[j] >= 0.0f ); // TODO can decide a threshold, right now checks only for +ve values
        }
        temp=temp->next;
    }
}

void seperateTrainingAndTestingData(
        s_group *in_groups,
        int in_num_groups
        )
{
    printf(" [ STEP ] Seperate data in to training set and testing set ... \n");
    int i,c,fcount=0;
    for( i=0; i<in_num_groups; i++)
    {
        for ( c=0; c<2; c++)
        {
            s_filelistnode *file = in_groups[i].list[c].list;
            int numfiles = in_groups[i].count;
            if( numfiles > 0)
            {
                while( file != NULL )
                {
                    fcount++;
                    if ( fcount%9 != 0)
                    {
                        addToList(&(in_groups[i].trainlist), file->prop);
                    }
                    else // fcount%9 == 0 FIXME You are probably over writing the test
                        // with same data
                    {
                        addToList(&(in_groups[i].testlist), file->prop);
                    }
                    file = file->next;
                }
            }
        }

    }
}

/*
    FIXME Try to get this code to naiveOperations.cu to make the code more structured
*/
void trainNaiveBayes(
        s_group   *in_groups,
        int       in_num_groups,
        int       in_num_opcodes,
        float     *out_trainArray,
        int       *out_train_class_vect
)
{
    printf(" [ STEP ] Train Naive Bayes on CPU ... \n");
    int i,k;
    int numtrainfiles=0;
    for ( i=0; i<in_num_groups; i++)
    {
        int numfiles = in_groups[i].count;
        if( numfiles <= 0) continue;

        s_filelistnode *file = in_groups[i].trainlist.list;
        if( in_groups[i].count <= 0) continue;
        int fileCountM = 0;
        int fileCountB = 0;
                int row = i*4;
        while( file != NULL )
        {
                int cls = file->prop->classId*2;
                if(cls) fileCountM++; else fileCountB++;
                out_train_class_vect[numtrainfiles] = file->prop->classId;
            for ( k=0; k< file->prop->numopcode; k++)
            {
                float normalizedval = file->prop->normalized_opcodes[k];
                int opcindex = file->prop->opcodes[k].id;

                assert( file->prop->opcodes[k].freq > 0 );

                float m = normalizedval;

                assert( m >= 0.0f );

                out_trainArray[((row+cls+MEAN)*in_num_opcodes)+opcindex] += m;
            }
        file = file->next;
        numtrainfiles++;
        }
        for( k=0;k<in_num_opcodes;k++)
        {
                if ( fileCountB )
                out_trainArray[((row+0+MEAN)*in_num_opcodes)+k] /= (float)fileCountB;

                if ( fileCountM )
                out_trainArray[((row+1+MEAN)*in_num_opcodes)+k] /= (float)fileCountM;
        }
        file = in_groups[i].trainlist.list;
        while( file != NULL )
        {
                int cls = file->prop->classId*2;
            for ( k=0; k< file->prop->numopcode; k++)
            {
                float normalizedval = file->prop->normalized_opcodes[k];
                int opcindex = file->prop->opcodes[k].id;

                assert( file->prop->opcodes[k].freq > 0 );

                float m = out_trainArray[((row+cls+MEAN)*in_num_opcodes)+opcindex] ;
                if( cls )
                    m /= fileCountM;
                    else
                        m/=fileCountB;

                float v = (m-normalizedval)*(m-normalizedval);
                assert( m >= 0.0f && v >= 0.0f);

                out_trainArray[((row+cls+VAR)*in_num_opcodes)+opcindex] += v;
            }
        file = file->next;
        numtrainfiles++;
        }

        for( k=0;k<in_num_opcodes;k++)
        {
                if( fileCountB)
                out_trainArray[((row+0+VAR)*in_num_opcodes)+k] /= (float)fileCountB;

                if( fileCountM)
                out_trainArray[((row+1+VAR)*in_num_opcodes)+k] /= (float)fileCountM;
        }
    }
}

void createTestingMatrix(
        s_group   *in_groups,
        int       in_num_groups,
        int       in_num_opcodes,
        float     *out_testArray,
        int       *out_test_class_vect,
        int       *out_group_vect

)
{
    printf(" [ STEP ] Create Tesing Matrix ... \n");
    printf("\t Currently using entire(training+testing) set as testing set ...\n");
    int i,k;
    int numtestfiles=0;
    for ( i=0; i<in_num_groups; i++)
    {
        int numfiles = in_groups[i].count;
        if( numfiles <= 0) continue;
        s_filelistnode *file = NULL;
        int fileCount = 0;

        file = in_groups[i].trainlist.list;
        fileCount = in_groups[i].trainlist.count;
        if( fileCount <= 0) continue;
        while( file != NULL )
        {
            for ( k=0; k< file->prop->numopcode; k++)
            {
                float normalizedval = file->prop->normalized_opcodes[k];
                int opcindex = file->prop->opcodes[k].id;

                out_testArray[(numtestfiles*in_num_opcodes)+opcindex] = normalizedval;
                out_test_class_vect[numtestfiles] = file->prop->classId;
                out_group_vect[numtestfiles]= (file->prop->size)/5;
            }
            file = file->next;
            numtestfiles++;
        }

        file = in_groups[i].testlist.list;
        fileCount = in_groups[i].testlist.count;
        if( fileCount <= 0) continue;
        while( file != NULL )
        {
            for ( k=0; k< file->prop->numopcode; k++)
            {
                float normalizedval = file->prop->normalized_opcodes[k];
                int opcindex = file->prop->opcodes[k].id;

                out_testArray[(numtestfiles*in_num_opcodes)+opcindex] += normalizedval;
                out_test_class_vect[numtestfiles] = file->prop->classId;
                out_group_vect[numtestfiles]= (file->prop->size)/5;
            }
            file = file->next;
            numtestfiles++;
        }
    }
}

void resetVector(
        float * out_vector,
        int in_num_columns
        )
{
    int i;
    for ( i=0; i<in_num_columns; i++)
    {
        out_vector[i] = 0.0;
    }
}

void selectFeaturesForEachGroup(
        s_group ** out_group,
        int in_num_groups,
        int in_num_opcodes,
        int in_num_features
        )
{
    printf(" [ STEP ] Selecting features for each group ...\n");
    int i,j,k,l;
    float **features=(float**) calloc( sizeof( float* ) , 2 );
    features[0]=(float*) calloc( sizeof( float ) , in_num_opcodes );
    features[1]=(float*) calloc( sizeof( float ) , in_num_opcodes );

    s_group *grp_ptr;
    for ( i=0; i<in_num_groups; i++)
    {
        grp_ptr = &((*out_group)[i]);
        if( grp_ptr->count > 0 )
        {
            resetVector( features[0], in_num_opcodes);
            resetVector( features[1], in_num_opcodes);

            for ( j=0; j< grp_ptr->count; j++)
            {
                for ( k=0; k<2; k++) // TODO NUM_CLASSES
                {
                    s_filelistnode *file = grp_ptr->list[k].list;
                    while( file != NULL )
                    {
                        s_fileProp *fileprop_ptr = file->prop;
                        for ( l=0; l<file->prop->numopcode; l++)
                        {
                            int opcindex = fileprop_ptr->opcodes[l].id;
                            int freq = fileprop_ptr->opcodes[l].freq;
                            features[k][opcindex] += (freq/grp_ptr->list[k].count) ; // TODO divided by number of files in each class
                        }
                        file=file->next;
                    }
                }

            }
            setFeatureVector( features, grp_ptr, 2, in_num_opcodes, in_num_features); // TODO NUM_CLASSES
        }
    }
    free( features[0] );
    free( features[1] );
    free( features );
}

int cmpopcodenode(
        const void * opc1,
        const void *opc2
        )
{
    s_diffnode a = *(s_diffnode const*) opc1;
    s_diffnode b = *(s_diffnode const*) opc2;

    if( a.diff < b.diff ) return 1; /// sorts in ascending order
    else return 0;
}

void setFeatureVector(
        float **in_features,
        s_group * out_group ,
        int in_num_list,
        int in_num_columns,
        int in_num_features
        )
{
    s_diffnode * diffvector = (s_diffnode*) calloc( sizeof(s_diffnode), in_num_columns);
    int j=0;
    for ( j=0; j<in_num_columns; j++)
    {
        diffvector[j].id = j;
        diffvector[j].diff = abs( in_features[0][j] - in_features[1][j] ); // TODO NUM_CLASSES
    }

    /// sort in ascending order
    qsort( diffvector, in_num_columns, sizeof(s_opcodenode), cmpopcodenode);

    out_group->features = (int*) calloc( sizeof(int), in_num_columns);

    for ( j=0; j<in_num_features; j++)
    {
        int opcindex = diffvector[j].id;
        out_group->features[ opcindex ] = 1;
    }
    free( diffvector );
}

void assignFeatureListForEachGroup(
        int ***out_feature_list,
        s_group *in_groups,
        int in_num_groups
        )
{
    int i;
    for ( i=0; i<in_num_groups; i++)
    {
        if( in_groups[i].count > 0 )
            (*out_feature_list)[i] = in_groups[i].features;
        else
            (*out_feature_list)[i] = NULL;
    }
}
void spillFeatureMatrix(
        int **in_featureptr,
        int *out_featurematrix,
        int in_numgroups,
        int in_numopcode,
        int in_numfeatures
        )
{
    int i,j,k;
    for( i=0; i<in_numgroups; i++)
    {
        if( in_featureptr[i] )
        {
            k=0;
            for( j=0; j<in_numopcode; j++)
            {
                if(in_featureptr[i][j])
                {
                    out_featurematrix[ i*in_numfeatures+(k++) ] = j;
                }
            }
        }
        else
        {
            printf(" No Features found !!\n");
            for( j=0; j<in_numfeatures; j++)
            {
                out_featurematrix[ i*in_numfeatures+(k++) ] = 0;
            }

        }
    }
}

// Reading trainned_model into the matrix
void read_trainning_matrix(char *filename, float *trainArray, int NUM_GROUPS, int numopcode)
{
  char * line=NULL;
  size_t len =0;
  ssize_t read;
  FILE *fp = fopen(filename,"r");
  if (fp == NULL)
    exit(EXIT_FAILURE);
  read=getline(&line,&len,fp); //----->>uncomment  in case if we want to skip the first line providing group heading
  int column=0;
  while((read=getline(&line,&len,fp))!=-1)
  {
    //printf("Retrieved line of length : %zu \n",read ); //---->>uncomment to check how many chars we have read in each line to ensure we are reading data correctly
    //printf("%s", line);

    int row=0;
    char *value=strtok(line,",\n");

    while (row<(NUM_GROUPS*4))
    {

      if(value != NULL)
      {
        float fvalue;
        fvalue=strtof(value,NULL);

        //printf("position : %d  ",row*5+column); // --> uncomment to check whether values are printing correctly
        //printf("%.5f\n",fvalue);
        trainArray[row*numopcode+column]=fvalue;

        row++;
        value=strtok(NULL,",\n");

      }
    }
    //printf("\n");


    column++;
  }

}
