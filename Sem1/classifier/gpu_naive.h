/*! \file gpu_naive.h */
#ifndef __gpunaive_H_
#define __gpunaive_H_
void pnaiveTrain( int *inmat, int *inclass, int *class_wise, float *outmat, float *class_prob, int inrows, int incolumns, int outrows);
void pnaiveTrain(
        int *inmat,     /*!< [in] input matrix */
        int *inclass,     /*!< [in] input class, for each file */
        int *class_wise,    /*!< [out] class wise total opcodes */
        float *outmat,     /*!< [out] probablity of each opcode in each class */
        float *class_prob,     /*!< [out] probility of each class */
        int inrows,     /*!< [in] number of opcodes*/
        int incolumns,     /*!< [in] total number of files*/
        int outrows    /*!< [in] number of classes */
        );
void passignClassUsingMeanVarianceData( 
        float *in_trainedMatrix,
        float *in_testMatrix,
        int in_numgropus,
        int in_numopcode,
        int in_numtestfiles,
        int *in_groupindexvector,
        int *out_predictvector
        );
float passignClassUsingMeanVarianceDataUsingFeatureSelection( 
        float *in_trainedMatrix, 
        float *in_testMatrix, 
        int *in_featureMatrix,
        int in_numgroups, 
        int in_numopcode, 
        int in_numfeatures,
        int in_numtestfiles, 
        int *in_groupindexvector, 
        int *out_predictvector
        );

float getCudaTime();
void startCudaTimer();
void endCudaTimer();
/*!
*  \brief Allocates rows X columns size of float matrix on device
*
*   Need to pass address of the pointer
*  \return  
*/
    template <typename T>
void createDeviceMatrix(
        T **mat,     /*! [out] Matrix pointer on device  */
        int rows,      /*!< [in] number of rows in the matrix */
        int columns    /*!< [in] number of columns in the matrix */
        )
{
    cudaError_t err;
    err = cudaSuccess;
    err = cudaMalloc( mat, rows*columns*sizeof(T) );
    if ( err != cudaSuccess )
    {
        fprintf(stderr, "#Error %s, %d.\n%s.", __FILE__, __LINE__, cudaGetErrorString(err));
        exit(EXIT_FAILURE);
    }
    // set all the values to zero 
    err = cudaMemset((*mat), 0, rows*columns*sizeof(T));
    if ( err != cudaSuccess )
    {
        fprintf(stderr, "#Error %s, %d.\n%s.", __FILE__, __LINE__, cudaGetErrorString(err));
        exit(EXIT_FAILURE);
    }
}
/*!
 *	\brief Transfer an Integer vector of size from host to the device memory
 *
 *   More Details ...
 *	\return  
 *	
 */
    template <typename T>
void transferToDevice(
        T *hostptr,     /*!< [in] host memory pointer */
        T *deviceptr,     /*!< [in] device memory pointer */
        int size    /*!< [in] size of data to be transfered in bytes */
        )
{
    cudaError_t err;
    err = cudaSuccess;
    err = cudaMemcpy(deviceptr, hostptr, sizeof(T)*size, cudaMemcpyHostToDevice);
    if(err != cudaSuccess)
    {
        fprintf(stderr, "#Error %s, %d.\n%s.", __FILE__, __LINE__, cudaGetErrorString(err));
        exit(EXIT_FAILURE);
    }
}
/*!
 *	\brief Transfer an Integer vector of size from device to the host memory
 *
 *   More Details ...
 *	\return  
 *	
 */
    template<typename T>
void transferFromDevice(
        T *hostptr,     /*!< [in] host memory pointer */
        T *deviceptr,     /*!< [in] device memory pointer */
        int size    /*!< [in] size of data to be transfered in bytes */
        )
{
    cudaError_t err;
    err = cudaSuccess;
    err = cudaMemcpy(hostptr, deviceptr, sizeof(T)*size, cudaMemcpyDeviceToHost);
    if(err != cudaSuccess)
    {
        fprintf(stderr, "#Error %s, %d.\n%s.", __FILE__, __LINE__, cudaGetErrorString(err));
        exit(EXIT_FAILURE);
    }
}
#endif//__gpunaive_H_
