#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include "opcodeFile.h"
#include "trie.h"
//#include "gpu_naive.h"
#include "naiveOperations.h"
#include "logger.h"
#define NUM_GROUPS 100
#ifndef NUM_FEATURES
#define NUM_FEATURES 20
#endif
#ifndef EQUAL_NUM_FILES
#define EQUAL_NUM_FILES 0
#endif
#define NUM_CLASSES 2
int main(int argc, char**argv)
{
    if( argc < 4 )
    {
        printf("Usage:  ./main.out <opcode_file> <benign_freq_csv1> <malware_freq_csv2c>.\n");
        return 0;
    }
    char *opcode_file = argv[1];
    char *freq_csv1   = argv[2];
    char *freq_csv2   = argv[3];
    struct timeval start_seq, end_seq, diff_seq;
    /*
       STEPS in Main:
       1. Initialize everthing
       2. Read Opcode List
       3. Read .csv for test data base
       4. Normalize opcode frequencies of each file
       5.
       7. Do feature selection for each group
       8. Create training and testing data
       9. Run NaiveBayes with Feature Selection and Grouping on CPU
      10. Check for Accuracy

     */


    int numopcode=0;
    int numfiles=0;
    s_trie *opcodelist = initTrie();
    s_files *filelist;
    s_group *grouplist;
    int *groupCount=NULL;
    initFiles(&filelist);
    initGroups(&grouplist, NUM_GROUPS);
    groupCount = createVector( NUM_GROUPS * NUM_CLASSES);

    numopcode = readOpcodeFile( opcode_file, &opcodelist);

    numfiles = readCSVFile( freq_csv1, numopcode, &filelist, groupCount);
    numfiles += readCSVFile( freq_csv2, numopcode, &filelist, groupCount);

    logShowFiles(filelist);
    normalizeOpcodeFrequency( &filelist);

    doGrouping( filelist, groupCount, &grouplist);
    logShowGroupWiseStats( grouplist, NUM_GROUPS);

    selectFeaturesForEachGroup( &grouplist, NUM_GROUPS, numopcode, NUM_FEATURES);
    logGroupWiseFeatures(grouplist, NUM_GROUPS, NUM_FEATURES, numopcode);
    int numtestfiles=numfiles;

    float *trainArray       = createFloatMatrix( NUM_GROUPS * 4, numopcode ); // MALWARE BENIGN MEAN VARIANCE  ... NUM_CLASSES * 2
    float *testArray        = createFloatMatrix( numtestfiles, numopcode );
    int   *train_class_vect = createVector( numtestfiles );
    int   *test_class_vect  = createVector( numtestfiles );
    int   *group_vect       = createVector( numtestfiles );
    seperateTrainingAndTestingData(grouplist, NUM_GROUPS);
    trainNaiveBayes(grouplist, NUM_GROUPS, numopcode, trainArray, train_class_vect);
    createTestingMatrix(grouplist, NUM_GROUPS, numopcode, testArray, test_class_vect, group_vect);

    logSingleGroupData( grouplist, trainArray, NUM_GROUPS, numopcode, NUM_FEATURES, 45);
    logTrainedMatrix( trainArray, NUM_GROUPS, numopcode);

    int   *test_grp_vect    = createVector( numtestfiles );
    int   *predict_vect     = createVector( numtestfiles );

    int **featurelist = (int**) malloc(sizeof(int**));
    createFeatureListForEachGroup( &featurelist, NUM_GROUPS );


    assignFeatureListForEachGroup( &featurelist, grouplist, NUM_GROUPS);
    int   *h_featureMatrix;
    h_featureMatrix = createIntMatrix( NUM_GROUPS , NUM_FEATURES);
    spillFeatureMatrix( featurelist, h_featureMatrix, NUM_GROUPS, numopcode, NUM_FEATURES);


    float *rotated_test_matrix=NULL;


    rotated_test_matrix = createFloatMatrix( numtestfiles, numopcode);
    rotateMatrixF( testArray, rotated_test_matrix, numtestfiles, numopcode);



    int i=0;

    logTimingData(0,0.0f,0.0f,0.0f);

    for ( i=256;i<numtestfiles; i+=256)
    {
        int files_to_process=i;
        float paralleltime =0.0;
        gettimeofday(&start_seq, NULL );
        assignClassUsingMeanVarianceDataAndFeatureSelection( trainArray, testArray, h_featureMatrix, NUM_GROUPS, numopcode, NUM_FEATURES, files_to_process, group_vect, predict_vect);
        gettimeofday(&end_seq, NULL );
        timersub(&end_seq,&start_seq,&diff_seq);
        float sequentialTime =  diff_seq.tv_sec*1000.0+ diff_seq.tv_usec/1000.0 ;

        int   *H_predict_vect;
        H_predict_vect = createVector( files_to_process );

        float acc = getAccuracy(test_class_vect, predict_vect, files_to_process);
        logTimingData(files_to_process, paralleltime, sequentialTime, acc);
    }

    logTestingData( testArray, group_vect, test_class_vect, predict_vect, numopcode, i-256, 45);



    free ( trainArray );
    free ( testArray );
    free ( test_class_vect );
    free ( train_class_vect );
    free ( group_vect );
    free ( predict_vect  );
    free ( h_featureMatrix );

    free     ( rotated_test_matrix );

    return 0;
}
