import keras
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import Dropout, Activation
from keras.models import model_from_json
from keras.models import load_model
from sklearn.model_selection import StratifiedKFold
import numpy
import time


## ************** Function for training and dumping the model  *************
def train(infile):
    seed=7

    #dataset = numpy.loadtxt("../pima-indians-diabetes.csv", delimiter=",")
    dataset = numpy.loadtxt(infile+".csv", delimiter=",")

    #split data-set
    #class label
    X = dataset[:,0]
    #fefature vectors
    Y = dataset[:,1:1809]

    #print X
    #print Y

    # define 10-fold cross validation test
    kfold = StratifiedKFold(n_splits=10, shuffle=True, random_state=seed)
    ccvscore =[]
    for train,test in kfold.split(Y,X):

        ## MOdel definitin

        model = Sequential()
        # using gaussian initializer to avoid multiplicative impact of weight aggregation
        # others can also be tried
        #act = keras.layers.advanced_activations.PReLU(init='normal', weights=None)
        #model.add(Dense(1,input_dim=1808, init ='uniform', activation ='sigmoid'))
        model.add(Dense(1808,input_dim=1808, init ='uniform'))
        model.add(keras.layers.advanced_activations.PReLU())
        model.add(Dropout(0.5))
        #model.add(Dense(1808,init ='uniform'))
        #model.add(keras.layers.advanced_activations.PReLU())
        #model.add(Dropout(0.3))
        model.add(Dense(1,activation='sigmoid'))

        # Compile model
        model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

        # Fit the model
        start_train= time.time()
        model.fit(Y[train], X[train], epochs=10,verbose=0)
        end_train=time.time()
        print "time elapsed in training   ",(end_train-start_train)
        #calculating time elapsed in predictions
        start = time.time()
        end =time.time()
        print "time elapsed in prediction   ",(end-start)

        # evaluate the model
        scores = model.evaluate(Y[test], X[test])
        print("\n%s: %.2f%%" % (model.metrics_names[1], scores[1]*100))

        ccvscore.append(scores[1]*100)

    print("%.2f%% (+/- %.2f%%)" % (numpy.mean(ccvscore), numpy.std(ccvscore)))


def main():
    f="/home/mayank/Desktop/data/testing/neural/train_wo_size"
    train (f)

if __name__ == "__main__":
    main()
